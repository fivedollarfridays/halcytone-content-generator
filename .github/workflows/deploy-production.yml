name: Deploy to Production

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip test suite (NOT RECOMMENDED)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even with warnings'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Step 1: Build and test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      test_coverage: ${{ steps.coverage.outputs.coverage }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version calculation

      - name: Calculate version
        id: version
        run: |
          VERSION=$(git describe --tags --always --dirty)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            .venv
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run linting
        run: |
          pip install black flake8 mypy
          black --check src/ tests/
          flake8 src/ tests/
          mypy src/ --ignore-missing-imports

      - name: Run security checks
        run: |
          pip install safety bandit
          safety check --json
          bandit -r src/ -f json -o bandit-report.json

      - name: Run tests with coverage
        if: ${{ !inputs.skip_tests }}
        run: |
          pytest tests/ \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term \
            --junit-xml=test-results.xml \
            -v

      - name: Calculate coverage
        id: coverage
        if: ${{ !inputs.skip_tests }}
        run: |
          COVERAGE=$(python -c "import xml.etree.ElementTree as ET; \
            tree = ET.parse('coverage.xml'); \
            root = tree.getroot(); \
            print(root.attrib['line-rate'])")
          COVERAGE_PCT=$(echo "$COVERAGE * 100" | bc -l | cut -d. -f1)
          echo "coverage=${COVERAGE_PCT}" >> $GITHUB_OUTPUT
          echo "Test Coverage: ${COVERAGE_PCT}%"

          # Fail if coverage is below threshold
          if [ "$COVERAGE_PCT" -lt "80" ]; then
            echo "::error::Test coverage ${COVERAGE_PCT}% is below required 80%"
            exit 1
          fi

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            test-results.xml
            coverage.xml
            htmlcov/
            bandit-report.json

      - name: Build Docker image
        run: |
          docker build \
            --build-arg VERSION=${{ steps.version.outputs.version }} \
            --tag halcytone-content-generator:${{ steps.version.outputs.version }} \
            --tag halcytone-content-generator:latest \
            .

      - name: Run container security scan
        run: |
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image \
            --severity HIGH,CRITICAL \
            --exit-code 1 \
            halcytone-content-generator:latest

      - name: Save Docker image
        run: |
          docker save halcytone-content-generator:latest | gzip > halcytone-content-generator.tar.gz

      - name: Upload Docker image
        uses: actions/upload-artifact@v3
        with:
          name: docker-image
          path: halcytone-content-generator.tar.gz
          retention-days: 7

  # Step 2: Configuration validation
  validate-config:
    name: Validate Production Configuration
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Validate production configuration
        env:
          ENVIRONMENT: production
        run: |
          python scripts/config_manager.py validate production

      - name: Test production readiness
        run: |
          python scripts/config_manager.py test-production

      - name: Check secrets availability
        env:
          AZURE_KEY_VAULT_URL: ${{ secrets.AZURE_KEY_VAULT_URL }}
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          python scripts/config_manager.py check-secrets --provider azure_key_vault

  # Step 3: Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-test, validate-config]
    environment:
      name: staging
      url: https://staging.halcytone.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v3
        with:
          name: docker-image

      - name: Load Docker image
        run: |
          gunzip -c halcytone-content-generator.tar.gz | docker load

      - name: Deploy to staging
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$STAGING_SSH_KEY" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key

          # Copy Docker image to staging
          scp -i ~/.ssh/staging_key \
            -o StrictHostKeyChecking=no \
            halcytone-content-generator.tar.gz \
            ${STAGING_USER}@${STAGING_HOST}:/tmp/

          # Deploy on staging server
          ssh -i ~/.ssh/staging_key \
            -o StrictHostKeyChecking=no \
            ${STAGING_USER}@${STAGING_HOST} << 'ENDSSH'
            cd /opt/halcytone

            # Load new image
            gunzip -c /tmp/halcytone-content-generator.tar.gz | docker load

            # Run database migrations
            docker-compose -f docker-compose.staging.yml run --rm app \
              python -m alembic upgrade head

            # Deploy with zero-downtime
            docker-compose -f docker-compose.staging.yml up -d --no-deps --scale app=2 app
            sleep 10
            docker-compose -f docker-compose.staging.yml up -d --no-deps app
            docker-compose -f docker-compose.staging.yml scale app=1

            # Health check
            curl -f http://localhost:8000/health || exit 1
          ENDSSH

      - name: Run smoke tests
        run: |
          # Wait for service to stabilize
          sleep 30

          # Run smoke tests against staging
          pytest tests/smoke/ \
            --base-url https://staging.halcytone.com \
            --api-key ${{ secrets.STAGING_API_KEY }} \
            -v

      - name: Performance test
        run: |
          # Run basic performance test
          pip install locust
          locust \
            --host https://staging.halcytone.com \
            --users 10 \
            --spawn-rate 2 \
            --time 60s \
            --headless \
            --only-summary

  # Step 4: Manual approval gate
  approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment:
      name: production-approval

    steps:
      - name: Request approval
        run: |
          echo "Staging deployment successful!"
          echo "Please review staging environment and approve production deployment."
          echo "Staging URL: https://staging.halcytone.com"
          echo "Version: ${{ needs.build-and-test.outputs.version }}"
          echo "Test Coverage: ${{ needs.build-and-test.outputs.test_coverage }}%"

  # Step 5: Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-test, approval]
    environment:
      name: production
      url: https://api.halcytone.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v3
        with:
          name: docker-image

      - name: Create deployment backup
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
          PROD_USER: ${{ secrets.PROD_USER }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$PROD_SSH_KEY" > ~/.ssh/prod_key
          chmod 600 ~/.ssh/prod_key

          # Create backup on production
          ssh -i ~/.ssh/prod_key \
            -o StrictHostKeyChecking=no \
            ${PROD_USER}@${PROD_HOST} << 'ENDSSH'
            cd /opt/halcytone

            # Backup current deployment
            BACKUP_NAME="backup-$(date +%Y%m%d-%H%M%S)"
            mkdir -p /backups/${BACKUP_NAME}

            # Save current Docker images
            docker save halcytone-content-generator:latest | \
              gzip > /backups/${BACKUP_NAME}/docker-image.tar.gz

            # Backup database
            docker-compose -f docker-compose.production.yml exec -T db \
              pg_dump -U halcytone halcytone_prod | \
              gzip > /backups/${BACKUP_NAME}/database.sql.gz

            # Save current configuration
            cp .env /backups/${BACKUP_NAME}/.env
            cp docker-compose.production.yml /backups/${BACKUP_NAME}/

            echo "${BACKUP_NAME}" > /tmp/last_backup
          ENDSSH

      - name: Deploy to production (Blue-Green)
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
          PROD_USER: ${{ secrets.PROD_USER }}
          VERSION: ${{ needs.build-and-test.outputs.version }}
        run: |
          # Copy new image to production
          scp -i ~/.ssh/prod_key \
            -o StrictHostKeyChecking=no \
            halcytone-content-generator.tar.gz \
            ${PROD_USER}@${PROD_HOST}:/tmp/

          # Deploy with blue-green strategy
          ssh -i ~/.ssh/prod_key \
            -o StrictHostKeyChecking=no \
            ${PROD_USER}@${PROD_HOST} << 'ENDSSH'
            cd /opt/halcytone

            # Load new image
            gunzip -c /tmp/halcytone-content-generator.tar.gz | docker load
            docker tag halcytone-content-generator:latest halcytone-content-generator:blue

            # Start blue environment
            docker-compose -f docker-compose.production.yml up -d app-blue

            # Wait for blue to be healthy
            for i in {1..30}; do
              if curl -f http://localhost:8001/health; then
                echo "Blue environment is healthy"
                break
              fi
              sleep 5
            done

            # Switch traffic to blue
            docker-compose -f docker-compose.production.yml exec nginx \
              sed -i 's/app-green/app-blue/g' /etc/nginx/nginx.conf
            docker-compose -f docker-compose.production.yml exec nginx \
              nginx -s reload

            # Stop green environment
            docker-compose -f docker-compose.production.yml stop app-green

            # Tag blue as new green for next deployment
            docker tag halcytone-content-generator:blue halcytone-content-generator:green
          ENDSSH

      - name: Verify production deployment
        env:
          PROD_URL: https://api.halcytone.com
        run: |
          # Health check
          curl -f ${PROD_URL}/health || exit 1

          # Version check
          DEPLOYED_VERSION=$(curl -s ${PROD_URL}/version | jq -r '.version')
          if [ "$DEPLOYED_VERSION" != "${{ needs.build-and-test.outputs.version }}" ]; then
            echo "Version mismatch! Expected ${{ needs.build-and-test.outputs.version }}, got ${DEPLOYED_VERSION}"
            exit 1
          fi

      - name: Run production smoke tests
        run: |
          pytest tests/smoke/ \
            --base-url https://api.halcytone.com \
            --api-key ${{ secrets.PROD_API_KEY }} \
            --production \
            -v

      - name: Update monitoring
        run: |
          # Update monitoring dashboards with new version
          curl -X POST \
            -H "Authorization: Bearer ${{ secrets.DATADOG_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{\"version\": \"${{ needs.build-and-test.outputs.version }}\", \"environment\": \"production\"}" \
            https://api.datadoghq.com/api/v1/events

  # Step 6: Post-deployment validation
  post-deploy-validation:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always()

    steps:
      - name: Check error rates
        run: |
          # Query monitoring for error rates
          ERROR_RATE=$(curl -s \
            -H "Authorization: Bearer ${{ secrets.DATADOG_API_KEY }}" \
            "https://api.datadoghq.com/api/v1/query?query=avg:app.error_rate{env:production}" | \
            jq -r '.series[0].pointlist[-1][1]')

          if (( $(echo "$ERROR_RATE > 1.0" | bc -l) )); then
            echo "::error::Error rate ${ERROR_RATE}% exceeds threshold"
            exit 1
          fi

      - name: Check response times
        run: |
          # Query monitoring for response times
          RESPONSE_TIME=$(curl -s \
            -H "Authorization: Bearer ${{ secrets.DATADOG_API_KEY }}" \
            "https://api.datadoghq.com/api/v1/query?query=avg:app.response_time{env:production}" | \
            jq -r '.series[0].pointlist[-1][1]')

          if (( $(echo "$RESPONSE_TIME > 1000" | bc -l) )); then
            echo "::warning::Response time ${RESPONSE_TIME}ms exceeds target"
          fi

      - name: Notify deployment success
        if: success()
        run: |
          # Send success notification
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "✅ Production deployment successful!",
              "attachments": [{
                "color": "good",
                "fields": [
                  {"title": "Version", "value": "${{ needs.build-and-test.outputs.version }}", "short": true},
                  {"title": "Coverage", "value": "${{ needs.build-and-test.outputs.test_coverage }}%", "short": true},
                  {"title": "Environment", "value": "Production", "short": true},
                  {"title": "URL", "value": "https://api.halcytone.com", "short": true}
                ]
              }]
            }'

  # Rollback job (triggered on failure)
  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deploy-validation]
    if: failure() && needs.deploy-production.result == 'failure'

    steps:
      - name: Trigger rollback
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
          PROD_USER: ${{ secrets.PROD_USER }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$PROD_SSH_KEY" > ~/.ssh/prod_key
          chmod 600 ~/.ssh/prod_key

          # Execute rollback
          ssh -i ~/.ssh/prod_key \
            -o StrictHostKeyChecking=no \
            ${PROD_USER}@${PROD_HOST} << 'ENDSSH'
            cd /opt/halcytone

            # Get last backup name
            BACKUP_NAME=$(cat /tmp/last_backup)

            # Restore Docker image
            gunzip -c /backups/${BACKUP_NAME}/docker-image.tar.gz | docker load

            # Restore configuration
            cp /backups/${BACKUP_NAME}/.env .env
            cp /backups/${BACKUP_NAME}/docker-compose.production.yml .

            # Restart services with previous version
            docker-compose -f docker-compose.production.yml up -d --force-recreate

            # Verify rollback
            sleep 30
            curl -f http://localhost:8000/health || exit 1
          ENDSSH

      - name: Notify rollback
        if: always()
        run: |
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "⚠️ Production deployment rolled back!",
              "attachments": [{
                "color": "warning",
                "fields": [
                  {"title": "Failed Version", "value": "${{ needs.build-and-test.outputs.version }}", "short": true},
                  {"title": "Action Required", "value": "Please investigate the deployment failure", "short": false}
                ]
              }]
            }'